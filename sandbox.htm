<!-- TUC Computer Graphics Course Sandbox -->

</script><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TUC Graphics - WebGL Sandbox</title>

<!-- external libraries for matrix calculations and maintenance -->
<script type="text/javascript" src="./sandbox_files/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="./sandbox_files/webgl-utils.js"></script>

<!-- Code for the vertex shader-->

<script id="shader-fs" type="x-shader/x-fragment">
    //necessary code for compatibility
    precision mediump float;
    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;
    uniform sampler2D uSampler;

    void main(void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
    }
</script>




<script id="shader-vs" type="x-shader/x-vertex">
//attributes for the vertex shader (different for every thread/core that will execute a copy of this)
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uAmbientColor;

    uniform vec3 uLightingDirection;
    uniform vec3 uDirectionalColor;

    uniform bool uUseLighting;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;

    void main(void) {
	
	//Each vertex is multiplied with the ModelView and Projection matrices and created a fragment
	    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;

        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 transformedNormal = uNMatrix * aVertexNormal;
            float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        }
    }
</script>

<!-- Code for the fragment shader-->


<!-- Javascript code for the main functionality of the WebGL application-->
<script type="text/javascript">

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }
        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


	
    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
		
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);
		
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

        //Koulieris
        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord"); 
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute); 

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        //Lighting
        shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
        shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
        shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightingDirection");
        shaderProgram.directionalColorUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColor");        
    }

    function handleLoadedTexture(texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    var wallsTexture;
    var moonTexture;
    var redGhostTexture;
    var blueGhostTexture;
    var greenGhostTexture;
    var scaredGhostTexture;
    var pelletsTexture;
    var sPelletsTexture;
    
    //Textures
    function initTexture() {
        wallsTexture = gl.createTexture();
        wallsTexture.image = new Image();
        wallsTexture.image.onload = function() {
          handleLoadedTexture(wallsTexture)
        }

        wallsTexture.image.src = "wall.png";

        
        moonTexture = gl.createTexture();
        moonTexture.image = new Image();
        moonTexture.image.onload = function() {
          handleLoadedTexture(moonTexture)
        }

        moonTexture.image.src = "pacman.png";

        redGhostTexture = gl.createTexture();
        redGhostTexture.image = new Image();
        redGhostTexture.image.onload = function() {
          handleLoadedTexture(redGhostTexture)
        }

        redGhostTexture.image.src = "redGhost.png";

        blueGhostTexture = gl.createTexture();
        blueGhostTexture.image = new Image();
        blueGhostTexture.image.onload = function() {
          handleLoadedTexture(blueGhostTexture)
        }

        blueGhostTexture.image.src = "blueGhost.png";

        greenGhostTexture = gl.createTexture();
        greenGhostTexture.image = new Image();
        greenGhostTexture.image.onload = function() {
          handleLoadedTexture(greenGhostTexture)
        }

        greenGhostTexture.image.src = "greenGhost.png";

        scaredGhostTexture = gl.createTexture();
        scaredGhostTexture.image = new Image();
        scaredGhostTexture.image.onload = function() {
          handleLoadedTexture(scaredGhostTexture)
        }

        scaredGhostTexture.image.src = "scaredGhost.png";

        pelletsTexture = gl.createTexture();
        pelletsTexture.image = new Image();
        pelletsTexture.image.onload = function() {
          handleLoadedTexture(pelletsTexture)
        }

        pelletsTexture.image.src = "pellet.png";

        sPelletsTexture = gl.createTexture();
        sPelletsTexture.image = new Image();
        sPelletsTexture.image.onload = function() {
          handleLoadedTexture(sPelletsTexture)
        }

        sPelletsTexture.image.src = "sPellet.png";
    }
    
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

        var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    
    }


	//Rotation function helper
	function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    var cubeVertexPositionBuffer;
    var cubeVertexNormalBuffer;
    var cubeVertexTextureCoordBuffer;
    var cubeVertexIndexBuffer;

    var moonVertexPositionBuffer;
    var moonVertexNormalBuffer;
    var moonVertexTextureCoordBuffer;
    var moonVertexIndexBuffer;

    var latitudeBands = 15;
    var longitudeBands = 15;
    var radius = 1;

	//Initialize VBOs, IBOs and color
    function initBuffers() {

        //Vertex Buffer Object
        cubeVertexPositionBuffer = gl.createBuffer();
        //Bind buffer to ARRAY_BUFFER
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        //every item has 3 coordinates (x,y,z)
        cubeVertexPositionBuffer.itemSize = 3;
        //we have 24 vertices
        cubeVertexPositionBuffer.numItems = 24;

        cubeVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
        var vertexNormals = [
            // Front face
           0.0,  0.0,  1.0,
           0.0,  0.0,  1.0,
           0.0,  0.0,  1.0,
           0.0,  0.0,  1.0,

          // Back face
           0.0,  0.0, -1.0,
           0.0,  0.0, -1.0,
           0.0,  0.0, -1.0,
           0.0,  0.0, -1.0,

          // Top face
           0.0,  1.0,  0.0,
           0.0,  1.0,  0.0,
           0.0,  1.0,  0.0,
           0.0,  1.0,  0.0,

          // Bottom face
           0.0, -1.0,  0.0,
           0.0, -1.0,  0.0,
           0.0, -1.0,  0.0,
           0.0, -1.0,  0.0,

          // Right face
           1.0,  0.0,  0.0,
           1.0,  0.0,  0.0,
           1.0,  0.0,  0.0,
           1.0,  0.0,  0.0,

          // Left face
          -1.0,  0.0,  0.0,
          -1.0,  0.0,  0.0,
          -1.0,  0.0,  0.0,
          -1.0,  0.0,  0.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
        cubeVertexNormalBuffer.itemSize = 3;
        cubeVertexNormalBuffer.numItems = 24;

        //Texture Coords for blocks
        cubeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        var textureCoords = [
          // Front face
              0.0, 0.0,
              1.0, 0.0,
              1.0, 1.0,
              0.0, 1.0,

              // Back face
              1.0, 0.0,
              1.0, 1.0,
              0.0, 1.0,
              0.0, 0.0,

              // Top face
              0.0, 1.0,
              0.0, 0.0,
              1.0, 0.0,
              1.0, 1.0,

              // Bottom face
              1.0, 1.0,
              0.0, 1.0,
              0.0, 0.0,
              1.0, 0.0,

              // Right face
              1.0, 0.0,
              1.0, 1.0,
              0.0, 1.0,
              0.0, 0.0,

              // Left face
              0.0, 0.0,
              1.0, 0.0,
              1.0, 1.0,
              0.0, 1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        cubeVertexTextureCoordBuffer.itemSize = 2;
        cubeVertexTextureCoordBuffer.numItems = 24;

        //Index Buffer Object
        //it joins sets of vertices into faces
        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
        //this numbers are positions in the VBO array above
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        //we have one item - the cube
        cubeVertexIndexBuffer.itemSize = 1;
        //we have 36 indices (6 faces, every face has 2 triangles, each triangle 3 vertices: 2x3x6=36)
        cubeVertexIndexBuffer.numItems = 36;

        








        //Actually the sphere buffer for pacman and the ghosts.Not the moon :P
        var vertexPositionData = [];
        var normalData = [];
        var textureCoordData = [];
        for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
            var theta = latNumber * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var longNumber=0; longNumber <= longitudeBands; longNumber++) {
                var phi = longNumber * 2 * Math.PI / longitudeBands;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);

                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1 - (longNumber / longitudeBands);
                var v = 1 - (latNumber / latitudeBands);

                normalData.push(x);
                normalData.push(y);
                normalData.push(z);
                textureCoordData.push(u);
                textureCoordData.push(v);
                vertexPositionData.push(radius * x);
                vertexPositionData.push(radius * y);
                vertexPositionData.push(radius * z);
            }
        }

        var indexData = [];
        for (var latNumber=0; latNumber < latitudeBands; latNumber++) {
            for (var longNumber=0; longNumber < longitudeBands; longNumber++) {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                indexData.push(first);
                indexData.push(second);
                indexData.push(first + 1);

                indexData.push(second);
                indexData.push(second + 1);
                indexData.push(first + 1);
            }
        }

        moonVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
        moonVertexNormalBuffer.itemSize = 3;
        moonVertexNormalBuffer.numItems = normalData.length / 3;

        moonVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
        moonVertexTextureCoordBuffer.itemSize = 2;
        moonVertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

        moonVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
        moonVertexPositionBuffer.itemSize = 3;
        moonVertexPositionBuffer.numItems = vertexPositionData.length / 3;

        moonVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
        moonVertexIndexBuffer.itemSize = 1;
        moonVertexIndexBuffer.numItems = indexData.length;

    






        //Pellet buffer
		cubePelletsPositionBuffer=gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, cubePelletsPositionBuffer);
		
		pelletSize=[
			// Front face
            -0.1, -0.1,  0.1,
             0.1, -0.1,  0.1,
             0.1,  0.1,  0.1,
            -0.1,  0.1,  0.1,

            // Back face
            -0.1, -0.1,  -0.1,
            -0.1,  0.1,  -0.1,
             0.1,  0.1,  -0.1,
             0.1, -0.1,  -0.1,

            // Top face
            -0.1,  0.1, -0.1,
            -0.1,  0.1,  0.1,
             0.1,  0.1,  0.1,
             0.1,  0.1, -0.1,

            // Bottom face
            -0.1, -0.1, -0.1,
             0.1, -0.1, -0.1,
             0.1, -0.1,  0.1,
            -0.1, -0.1,  0.1,

            // Right face
             0.1, -0.1, -0.1,
             0.1,  0.1, -0.1,
             0.1,  0.1,  0.1,
             0.1, -0.1,  0.1,

            // Left face
            -0.1, -0.1, -0.1,
            -0.1, -0.1,  0.1,
            -0.1,  0.1,  0.1,
            -0.1,  0.1, -0.1
			]
			
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pelletSize), gl.STATIC_DRAW);
        cubePelletsPositionBuffer.itemSize = 3;
        cubePelletsPositionBuffer.numItems = 24;
		
		cubePelletsIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubePelletsIndexBuffer);
        var cubePelletIndices = [
		//this numbers are positions in the VBO array above
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubePelletIndices), gl.STATIC_DRAW);
        //we have one item - the cube
		cubePelletsIndexBuffer.itemSize = 1;
		//we have 36 indices (6 faces, every face has 2 triangles, each triangle 3 vertices: 2x3x6=36)
        cubePelletsIndexBuffer.numItems = 36;
		
		//Super Pellet buffer
		cubeSPelletsPositionBuffer=gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeSPelletsPositionBuffer);
		
		SpelletSize=[
			// Front face
            -0.3, -0.3,  0.3,
             0.3, -0.3,  0.3,
             0.3,  0.3,  0.3,
            -0.3,  0.3,  0.3,

            // Back face
            -0.3, -0.3, -0.3,
            -0.3,  0.3, -0.3,
             0.3,  0.3, -0.3,
             0.3, -0.3, -0.3,

            // Top face
            -0.3,  0.3, -0.3,
            -0.3,  0.3,  0.3,
             0.3,  0.3,  0.3,
             0.3,  0.3, -0.3,

            // Bottom face
            -0.3, -0.3, -0.3,
             0.3, -0.3, -0.3,
             0.3, -0.3,  0.3,
            -0.3, -0.3,  0.3,

            // Right face
             0.3, -0.3, -0.3,
             0.3,  0.3, -0.3,
             0.3,  0.3,  0.3,
             0.3, -0.3,  0.3,

            // Left face
            -0.3, -0.3, -0.3,
            -0.3, -0.3,  0.3,
            -0.3,  0.3,  0.3,
            -0.3,  0.3, -0.3
			]
			
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(SpelletSize), gl.STATIC_DRAW);
        cubeSPelletsPositionBuffer.itemSize = 3;
        cubeSPelletsPositionBuffer.numItems = 24;
		
		cubeSPelletsIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeSPelletsIndexBuffer);
        var cubeSPelletIndices = [
		//this numbers are positions in the VBO array above
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeSPelletIndices), gl.STATIC_DRAW);
        //we have one item - the cube
		cubeSPelletsIndexBuffer.itemSize = 1;
		//we have 36 indices (6 faces, every face has 2 triangles, each triangle 3 vertices: 2x3x6=36)
        cubeSPelletsIndexBuffer.numItems = 36;     
        
    }

	//Helper Variables
	var xTrans = 0.0;
	var yTrans = 0.0;
	
	var level1Counter=0;
	var level1Complete=0;
	
	var level2Counter=0;
	var level2Complete=0;

	var movDirection = true;
	
	//array for keeping pressed keys
	var currentlyPressedKeys = {};

	//Keyboard handler
	//do not touch :) 
    function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;

        if (String.fromCharCode(event.keyCode) == "F") {
            filter += 1;
            if (filter == 3) {
                filter = 0;
            }
        }
    }


	//Keyboard handler
	//do not touch :) 
    function handleKeyUp(event) {
        currentlyPressedKeys[event.keyCode] = false;
    }

	//Key pressed callback
	//37-40 are the codes for the arrow keys
	//xTrans + yTrans are used in the ModelView matrix for local transformation of the cube
	
    var lives=3;
    var score=0;

    var xGenTrans=0.0;
    var yGenTrans=0.0;

    var counterLeftTrans=0;
    var counterRightTrans=0;
    var counterUpTrans=0;
    var counterDownTrans=0;

    var pacMoveDirection=37;

    var superTime=0;
    var superHelp1=0;
    var superHelp2=0;
    var superHelp3=0;

    var pressedKey=0;

	var level1=new Array(11);
	for (var i=0;i<11;i++){
		level1[i]=new Array(19);
	}
	level1 = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
			  [0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0],
			  [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
			  [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
			  [1,2,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,2,1],
			  [1,0,0,1,0,0,0,0,0,3,0,0,0,0,0,1,0,0,1],
			  [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
			  [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
			  [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
			  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
			  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];

    level1g = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
               [0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0],
               [1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
               [1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1],
               [1,2,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,2,1],
               [1,0,0,1,0,0,0,0,0,3,0,0,0,0,0,1,0,0,1],
               [1,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
               [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1],
               [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
               [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
               [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];

    level1g2 = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0],
                [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
                [1,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1],
                [1,2,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,2,1],
                [1,0,0,1,0,0,0,1,0,3,0,1,0,0,0,1,0,0,1],
                [1,1,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
                [1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1],
                [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
				 
	var level2=new Array(11);
	for (var i=0;i<11;i++){
		level2[i]=new Array(19);
	}
	level2 = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    			  [1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
    			  [1,0,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1],
    			  [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
    			  [1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],
    			  [0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
    			  [1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1],
    			  [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
    			  [1,0,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1],
    			  [1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
    			  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];


    level2g2 = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
                [1,0,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1],
                [1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
                [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],
                [0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
                [1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1],
                [1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1],
                [1,0,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1],
                [1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];


    level2g3 = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,2,1,0,0,0,0,0,0,1,0,0,0,0,0,2,0,1],
                [1,0,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1],
                [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                [1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],
                [0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0],
                [1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1],
                [1,0,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1],
                [1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
	
    function handleKeys() {
        
        //If for example pacman moves right and up is pressed,he will go up as 
        //soon as he finds room
        //This piece of code does this
        if (level1Complete==1){
            //Left move
            if (pacMoveDirection==37){
                if (currentlyPressedKeys[40]){
                    pressedKey=40;
                }
                if (currentlyPressedKeys[38]){
                    pressedKey=38;
                }
                if (currentlyPressedKeys[39]){
                    pressedKey=39;
                }
            }
            if (pressedKey==40 && pacMoveDirection==37){
                if (level2[parseInt(-1*yGenTrans)/2+5+1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=37;
                }
                else{
                    pacMoveDirection=40;
                    pressedKey=0;
                }
            }
            if (pressedKey==38 && pacMoveDirection==37){
                if (level2[parseInt(-1*yGenTrans)/2+5-1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=37;
                }
                else{
                    pacMoveDirection=38;
                    pressedKey=0;
                }
            }
            if (pressedKey==39 && pacMoveDirection==37){
                if (level2[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9-1]==1){
                    pacMoveDirection=37;
                }
                else{
                    pacMoveDirection=39;
                    pressedKey=0;
                }
            }

            //Up move
            if (pacMoveDirection==38){
                if (currentlyPressedKeys[40]){
                    pressedKey=40;
                }
                if (currentlyPressedKeys[39]){
                    pressedKey=39;
                }
                if (currentlyPressedKeys[37]){
                    pressedKey=37;
                }
            }
            if (pressedKey==40 && pacMoveDirection==38){
                if (level2[parseInt(-1*yGenTrans)/2+5-1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=38;
                }
                else{
                    pacMoveDirection=40;
                    pressedKey=0;
                }
            }
            if (pressedKey==37 && pacMoveDirection==38){
                if (level2[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9-1]==1){
                    pacMoveDirection=38;
                }
                else{
                    pacMoveDirection=37;
                    pressedKey=0;
                }
            }
            if (pressedKey==39 && pacMoveDirection==38){
                if (level2[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9+1]==1){
                    pacMoveDirection=38;
                }
                else{
                    pacMoveDirection=39;
                    pressedKey=0;
                }
            }

            //Right move
            if (pacMoveDirection==39){
                if (currentlyPressedKeys[40]){
                    pressedKey=40;
                }
                if (currentlyPressedKeys[38]){
                    pressedKey=38;
                }
                if (currentlyPressedKeys[37]){
                    pressedKey=37;
                }
            }
            if (pressedKey==40 && pacMoveDirection==39){
                if (level2[parseInt(-1*yGenTrans)/2+5+1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=39;
                }
                else{
                    pacMoveDirection=40;
                    pressedKey=0;
                }
            }
            if (pressedKey==37 && pacMoveDirection==39){
                if (level2[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9-1]==1){
                    pacMoveDirection=39;
                }
                else{
                    pacMoveDirection=37;
                    pressedKey=0;
                }
            }
            if (pressedKey==38 && pacMoveDirection==39){
                if (level2[parseInt(-1*yGenTrans)/2+5-1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=39;
                }
                else{
                    pacMoveDirection=38;
                    pressedKey=0;
                }
            }

            //Down move
            if (pacMoveDirection==40){
                if (currentlyPressedKeys[39]){
                    pressedKey=39;
                }
                if (currentlyPressedKeys[38]){
                    pressedKey=38;
                }
                if (currentlyPressedKeys[37]){
                    pressedKey=37;
                }
            }
            if (pressedKey==39 && pacMoveDirection==40){
                if (level2[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9+1]==1){
                    pacMoveDirection=40;
                }
                else{
                    pacMoveDirection=39;
                    pressedKey=0;
                }
            }
            if (pressedKey==37 && pacMoveDirection==40){
                if (level2[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9-1]==1){
                    pacMoveDirection=40;
                }
                else{
                    pacMoveDirection=37;
                    pressedKey=0;
                }
            }
            if (pressedKey==38 && pacMoveDirection==40){
                if (level2[parseInt(-1*yGenTrans)/2+5+1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=40;
                }
                else{
                    pacMoveDirection=38;
                    pressedKey=0;
                }
            }
        }
        else{


            //Level 1
            //Left move
            if (pacMoveDirection==37){
                if (currentlyPressedKeys[40]){
                    pressedKey=40;
                }
                if (currentlyPressedKeys[38]){
                    pressedKey=38;
                }
                if (currentlyPressedKeys[39]){
                    pressedKey=39;
                }
                if (currentlyPressedKeys[37]){
                    pressedKey=37;
                }
            }
            if (pressedKey==40 && pacMoveDirection==37){
                if (level1[parseInt(-1*yGenTrans)/2+5+1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=37;
                }
                else{
                    pacMoveDirection=40;
                    pressedKey=0;
                }
            }
            if (pressedKey==38 && pacMoveDirection==37){
                if (level1[parseInt(-1*yGenTrans)/2+5-1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=37;
                }
                else{
                    pacMoveDirection=38;
                    pressedKey=0;
                }
            }
            if (pressedKey==39 && pacMoveDirection==37){
                if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9-1]==1){
                    pacMoveDirection=37;
                }
                else{
                    pacMoveDirection=39;
                    pressedKey=0;
                }
            }
            if (pressedKey==37 && pacMoveDirection==37){
                if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9+1]==1){
                    pacMoveDirection=37;
                }
                else{
                    pacMoveDirection=37;
                    pressedKey=0;
                }
            }

            //Up move
            if (pacMoveDirection==38){
                if (currentlyPressedKeys[40]){
                    pressedKey=40;
                }
                if (currentlyPressedKeys[39]){
                    pressedKey=39;
                }
                if (currentlyPressedKeys[37]){
                    pressedKey=37;
                }
                if (currentlyPressedKeys[38]){
                    pressedKey=38;
                }
            }
            if (pressedKey==40 && pacMoveDirection==38){
                if (level1[parseInt(-1*yGenTrans)/2+5-1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=38;
                }
                else{
                    pacMoveDirection=40;
                    pressedKey=0;
                }
            }
            if (pressedKey==37 && pacMoveDirection==38){
                if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9-1]==1){
                    pacMoveDirection=38;
                }
                else{
                    pacMoveDirection=37;
                    pressedKey=0;
                }
            }
            if (pressedKey==39 && pacMoveDirection==38){
                if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9+1]==1){
                    pacMoveDirection=38;
                }
                else{
                    pacMoveDirection=39;
                    pressedKey=0;
                }
            }
            if (pressedKey==38 && pacMoveDirection==38){
                if (level1[parseInt(-1*yGenTrans)/2+5+1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=38;
                }
                else{
                    pacMoveDirection=38;
                    pressedKey=0;
                }
            }

            //Right move
            if (pacMoveDirection==39){
                if (currentlyPressedKeys[40]){
                    pressedKey=40;
                }
                if (currentlyPressedKeys[38]){
                    pressedKey=38;
                }
                if (currentlyPressedKeys[37]){
                    pressedKey=37;
                }
                if (currentlyPressedKeys[39]){
                    pressedKey=39;
                }
            }
            if (pressedKey==40 && pacMoveDirection==39){
                if (level1[parseInt(-1*yGenTrans)/2+5+1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=39;
                }
                else{
                    pacMoveDirection=40;
                    pressedKey=0;
                }
            }
            if (pressedKey==37 && pacMoveDirection==39){
                if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9-1]==1){
                    pacMoveDirection=39;
                }
                else{
                    pacMoveDirection=37;
                    pressedKey=0;
                }
            }
            if (pressedKey==38 && pacMoveDirection==39){
                if (level1[parseInt(-1*yGenTrans)/2+5-1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=39;
                }
                else{
                    pacMoveDirection=38;
                    pressedKey=0;
                }
            }
            if (pressedKey==39 && pacMoveDirection==39){
                if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9+1]==1){
                    pacMoveDirection=39;
                }
                else{
                    pacMoveDirection=39;
                    pressedKey=0;
                }
            }

            //Down move
            if (pacMoveDirection==40){
                if (currentlyPressedKeys[39]){
                    pressedKey=39;
                }
                if (currentlyPressedKeys[38]){
                    pressedKey=38;
                }
                if (currentlyPressedKeys[37]){
                    pressedKey=37;
                }
                if (currentlyPressedKeys[40]){
                    pressedKey=40;
                }
            }
            if (pressedKey==39 && pacMoveDirection==40){
                if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9+1]==1){
                    pacMoveDirection=40;
                }
                else{
                    pacMoveDirection=39;
                    pressedKey=0;
                }
            }
            if (pressedKey==37 && pacMoveDirection==40){
                if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9-1]==1){
                    pacMoveDirection=40;
                }
                else{
                    pacMoveDirection=37;
                    pressedKey=0;
                }
            }
            if (pressedKey==38 && pacMoveDirection==40){
                if (level1[parseInt(-1*yGenTrans)/2+5+1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=40;
                }
                else{
                    pacMoveDirection=38;
                    pressedKey=0;
                }
            }
            if (pressedKey==40 && pacMoveDirection==40){
                if (level1[parseInt(-1*yGenTrans)/2+5-1][parseInt(xGenTrans)/2+9]==1){
                    pacMoveDirection=40;
                }
                else{
                    pacMoveDirection=40;
                    pressedKey=0;
                }
            }
        }
        
		



        //This is the collision detection part
        //When moving to a specific location,this code checks if there is room or not(wall or pellet)
		if (level1Complete==1){
            //Level 2 collision detection
			if (pacMoveDirection==37) {
                // Left cursor key
                if (level2[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9-1]!=1){
                    xTrans=xTrans-0.1;
                    counterLeftTrans=counterLeftTrans+0.1;
                    if (counterLeftTrans>2){
                        xGenTrans = xGenTrans-2;
                        xTrans=xGenTrans;
                        counterLeftTrans=0;
                    }
                }
            }
            if (pacMoveDirection==39) {
                // Right cursor key
                if (level2[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9+1]!=1){
                    xTrans=xTrans+0.1;
                    counterRightTrans=counterRightTrans+0.1;
                    if (counterRightTrans>2){
                        xGenTrans = xGenTrans+2;
                        xTrans=xGenTrans;
                        counterRightTrans=0;
                    }
                }
            }
            if (pacMoveDirection==38) {
                // Up cursor key
                if (level2[parseInt(-1*yGenTrans)/2+5-1][parseInt(xGenTrans)/2+9]!=1){
                    yTrans = yTrans+0.1;
                    counterUpTrans=counterUpTrans+0.1;
                    if (counterUpTrans>2){
                        yGenTrans=yGenTrans+2;
                        yTrans=yGenTrans;
                        counterUpTrans=0;
                    }
                }
            }
            if (pacMoveDirection==40) {
                // Down cursor key
                if (level2[parseInt(-1*yGenTrans)/2+5+1][parseInt(xGenTrans)/2+9]!=1){
                    yTrans = yTrans-0.1;
                    counterDownTrans=counterDownTrans+0.1;
                    if (counterDownTrans>2){
                        yGenTrans=yGenTrans-2;
                        yTrans=yGenTrans;
                        counterDownTrans=0;
                    }
                }
            }
            
            //Side
            if (yGenTrans==0 && xGenTrans<-18){
                xGenTrans=18;
            }
            if (yGenTrans==0 && xGenTrans>18){
                xGenTrans=-18;
            }
            
            //Simple pellet
            if (level2[parseInt(-1*yGenTrans)/2+5][parseInt(-1*xGenTrans)/2+9]==0){
                level2[parseInt(-1*yGenTrans)/2+5][parseInt(-1*xGenTrans)/2+9]=3;
                level2Counter++;
                score=score+10;
            }
            //Super pellet
            if (level2[parseInt(-1*yGenTrans)/2+5][parseInt(-1*xGenTrans)/2+9]==2){
                level2[parseInt(-1*yGenTrans)/2+5][parseInt(-1*xGenTrans)/2+9]=3;
                level2Counter++;
                superTime=1;
                superHelp1=1;
                superHelp2=1;
                superHelp3=1;
                firstTime=new Date().getTime();
                score=score+30;
            }
            if (superTime==1){
                nextTime=new Date().getTime();
                if (nextTime-firstTime>5000){
                    superTime=0;
                }
            }
            
            //Level 2 complete
            if (level2Counter==104){
                level2Complete=1;
                level2Counter=1;
                document.getElementById("win").style.display="block";
                document.getElementById("TUCWebGL").style.display="none";
            }
		}
		else{
            //level1Complete=1;
            //Level 1 collision detection
			if (pacMoveDirection==37) {
				// Left cursor key
				if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9-1]!=1){
                    xTrans=xTrans-0.1;
                    counterLeftTrans=counterLeftTrans+0.1;
                    if (counterLeftTrans>2){
                        xGenTrans = xGenTrans-2;
                        xTrans=xGenTrans;
                        counterLeftTrans=0;
                    }
				}
			}
			if (pacMoveDirection==39) {
				// Right cursor key
				if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(xGenTrans)/2+9+1]!=1){
					xTrans=xTrans+0.1;
                    counterRightTrans=counterRightTrans+0.1;
                    if (counterRightTrans>2){
                        xGenTrans = xGenTrans+2;
                        xTrans=xGenTrans;
                        counterRightTrans=0;
                    }
				}
			}
			if (pacMoveDirection==38) {
				// Up cursor key
				if (level1[parseInt(-1*yGenTrans)/2+5-1][parseInt(xGenTrans)/2+9]!=1){
					yTrans = yTrans+0.1;
                    counterUpTrans=counterUpTrans+0.1;
                    if (counterUpTrans>2){
                        yGenTrans=yGenTrans+2;
                        yTrans=yGenTrans;
                        counterUpTrans=0;
                    }
				}
			}
			if (pacMoveDirection==40) {
				// Down cursor key
				if (level1[parseInt(-1*yGenTrans)/2+5+1][parseInt(xGenTrans)/2+9]!=1){
					yTrans = yTrans-0.1;
                    counterDownTrans=counterDownTrans+0.1;
                    if (counterDownTrans>2){
                        yGenTrans=yGenTrans-2;
                        yTrans=yGenTrans;
                        counterDownTrans=0;
                    }
				}
			}
		    
            //Side
			if (yGenTrans==8 && xGenTrans<-18){
				xGenTrans=18;
			}
			if (yGenTrans==8 && xGenTrans>18){
				xGenTrans=-18;
			}
		    
            //Simple pellet
			if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(-1*xGenTrans)/2+9]==0){
				level1[parseInt(-1*yGenTrans)/2+5][parseInt(-1*xGenTrans)/2+9]=3;
				level1Counter++;
                score=score+10;
			}
            //Super pellet
            if (level1[parseInt(-1*yGenTrans)/2+5][parseInt(-1*xGenTrans)/2+9]==2){
                level1[parseInt(-1*yGenTrans)/2+5][parseInt(-1*xGenTrans)/2+9]=3;
                level1Counter++;
                superTime=1;
                superHelp1=1;
                superHelp2=1;
                superHelp3=1;
                firstTime=new Date().getTime();
                score=score+30;
            }
            if (superTime==1){
                nextTime=new Date().getTime();
                if (nextTime-firstTime>5000){
                    superTime=0;
                }
            }
		    
            //Level 1 complete
			if (level1Counter==98){
				level1Complete=1;
				level1Counter=1;
                counterLeftTrans=0;
                counterRightTrans=0;
                counterUpTrans=0;
                counterDownTrans=0;
                xGenTrans=0;
                yGenTrans=0;
				xTrans=0.0;
				yTrans=0.0;
				alert("Level 1 Complete!!");
			}
		}
    }
	
	//For every frame this function draws the complete scene from the beginning
    function drawScene() {


		if (level1Complete==1){
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
                   mat4.identity(mvMatrix);
            

            //Implementation for 2 cameras for level 2
            if (superTime==0){
                mat4.translate(mvMatrix, [0.0, 0.0, -40.0]);
            }
            else{
                zcam=-30;
                
                mat4.translate(mvMatrix, [-xTrans, -yTrans, -35.0]);
                mat4.rotate(mvMatrix, degToRad(zcam),[1,0,0]);
            }
            

            //Lighting code
            gl.uniform1i(shaderProgram.useLightingUniform, true);
            gl.uniform3f(shaderProgram.ambientColorUniform, 0.2, 0.2, 0.2);
            var lightingDirection = [0.5, -0.5, -6];
            var adjustedLD = vec3.create();
            vec3.normalize(lightingDirection, adjustedLD);
            vec3.scale(adjustedLD, -1);
            gl.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);
            gl.uniform3f(shaderProgram.directionalColorUniform, 0.8, 0.8, 0.8);






            //Pacman
            mvPushMatrix();
            mat4.translate(mvMatrix, [xTrans, yTrans, 5]);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, moonTexture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, moonVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, moonVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, moonVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();



            //Ghost 1

            mvPushMatrix();
            mat4.translate(mvMatrix, [L2ghost1xTrans, L2ghost1yTrans, 5]);

            //Load the appropriate texture whether or not pacman has eaten a pellet
            if (superTime==0){
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, redGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }
            else{
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, scaredGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }
            
            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, moonVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, moonVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, moonVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();



            //Ghost 2

            mvPushMatrix();

            mat4.translate(mvMatrix, [L2ghost2xTrans, L2ghost2yTrans, 5]);

            if (superTime==0){
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, blueGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }
            else{
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, scaredGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, moonVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, moonVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, moonVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();



            //Ghost 3
            mvPushMatrix();

            mat4.translate(mvMatrix, [L2ghost3xTrans, L2ghost3yTrans, 5]);

            if (superTime==0){
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, greenGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }
            else{
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, scaredGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }
        
            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, moonVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, moonVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, moonVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();

			//Draw level 2		  
			for (var i=0;i<11;i++){
				for (var j=0;j<19;j++){
					if (level2[i][j]==1){
						gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
                        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
                        
                        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
                        
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, wallsTexture);
                        gl.uniform1i(shaderProgram.samplerUniform, 0);
                        
                        mvPushMatrix();
                        mat4.translate(mvMatrix, [-(j-18 +j), -(i-10 +i) , 5 ]);
                        setMatrixUniforms();
                        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                        mvPopMatrix();
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
					}
					if (level2[i][j]==0){
						gl.bindBuffer(gl.ARRAY_BUFFER, cubePelletsPositionBuffer);
                        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubePelletsPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, pelletsTexture);
                        gl.uniform1i(shaderProgram.samplerUniform, 0);

                        mvPushMatrix();
                        mat4.translate(mvMatrix, [-(j-18 +j), -(i-10 +i) , 5 ]);
                        setMatrixUniforms();
                        gl.drawElements(gl.TRIANGLES, cubePelletsIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                        mvPopMatrix();
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubePelletsIndexBuffer);
					}
					if (level2[i][j]==2){
						gl.bindBuffer(gl.ARRAY_BUFFER, cubeSPelletsPositionBuffer);
                        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeSPelletsPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, sPelletsTexture);
                        gl.uniform1i(shaderProgram.samplerUniform, 0);

                        mvPushMatrix();
                        mat4.translate(mvMatrix, [-(j-18 +j), -(i-10 +i) , 5 ]);
                        setMatrixUniforms();
                        gl.drawElements(gl.TRIANGLES, cubeSPelletsIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                        mvPopMatrix();
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeSPelletsIndexBuffer);
					}
				}
			}
		}
		else{
            //Level 1
      		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

            mat4.identity(mvMatrix);

            //Lighting code
            gl.uniform1i(shaderProgram.useLightingUniform, true);
            gl.uniform3f(shaderProgram.ambientColorUniform, 0.2, 0.2, 0.2);
            var lightingDirection = [0.25, 0.25, -0.25];
            var adjustedLD = vec3.create();
            vec3.normalize(lightingDirection, adjustedLD);
            vec3.scale(adjustedLD, -1);
            gl.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);
            gl.uniform3f(shaderProgram.directionalColorUniform, 0.8, 0.8, 0.8);


            //2 cameras for level 1 as well
            if (superTime==0){
                mat4.translate(mvMatrix, [0.0, 0.0, -40.0]);
            }
            else{
                mat4.translate(mvMatrix, [-xTrans, -yTrans, -25.0]);
            }
			

            //Pacman
            mvPushMatrix();

            mat4.translate(mvMatrix, [xTrans, yTrans, 5]);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, moonTexture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, moonVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, moonVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, moonVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();

            //Ghost 1

            mvPushMatrix();

            mat4.translate(mvMatrix, [ghost1xTrans, ghost1yTrans, 5]);

            if (superTime==0){
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, redGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }
            else{
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, scaredGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }
            
            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, moonVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, moonVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, moonVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();


            //Ghost 2

            mvPushMatrix();

            mat4.translate(mvMatrix, [ghost2xTrans, ghost2yTrans, 5]);

            if (superTime==0){
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, blueGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }
            else{
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, scaredGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, moonVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, moonVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, moonVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();

            //Ghost 3

            mvPushMatrix();

            mat4.translate(mvMatrix, [ghost3xTrans, ghost3yTrans, 5]);

            if (superTime==0){
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, greenGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }
            else{
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, scaredGhostTexture);
                gl.uniform1i(shaderProgram.samplerUniform, 0);
            }
        
            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, moonVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, moonVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, moonVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();


			//Draw Level 1
			for (var i=0;i<11;i++){
				for (var j=0;j<19;j++){
					if (level1[i][j]==1){
						gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
						gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                        
                        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
                        
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, wallsTexture);
                        gl.uniform1i(shaderProgram.samplerUniform, 0);

                        
                        
                        mvPushMatrix();
                        mat4.translate(mvMatrix, [-(j-18 +j), -(i-10 +i) , 5 ]);

                        


                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                        setMatrixUniforms();
                        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                        mvPopMatrix();
                                    						 						 
					}

					if (level1[i][j]==0){
						gl.bindBuffer(gl.ARRAY_BUFFER, cubePelletsPositionBuffer);
						gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubePelletsPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, pelletsTexture);
                        gl.uniform1i(shaderProgram.samplerUniform, 0);

                        mvPushMatrix();
                        mat4.translate(mvMatrix, [-(j-18 +j), -(i-10 +i) , 5 ]);
                        setMatrixUniforms();
                        gl.drawElements(gl.TRIANGLES, cubePelletsIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                        mvPopMatrix();
						gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubePelletsIndexBuffer);
						
						
						
						
						
					}
					if (level1[i][j]==2){
						gl.bindBuffer(gl.ARRAY_BUFFER, cubeSPelletsPositionBuffer);
                        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeSPelletsPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, sPelletsTexture);
                        gl.uniform1i(shaderProgram.samplerUniform, 0);

                        mvPushMatrix();
                        mat4.translate(mvMatrix, [-(j-18 +j), -(i-10 +i) , 5 ]);
                        setMatrixUniforms();
                        gl.drawElements(gl.TRIANGLES, cubeSPelletsIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                        mvPopMatrix();
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeSPelletsIndexBuffer);
					}
				}
			}
		}
    }

    //Ghost 1 Variables
    var ghost1xGenTrans=-16;
    var ghost1yGenTrans=8;
    var ghost1xTrans=-16;
    var ghost1yTrans=8;
    var ghost1RightCounter=0;
    var ghost1UpCounter=0;
    var ghost1DownCounter=0;
    var ghost1LeftCounter=0;
    var ghost1Direction=3;

    //Ghost 2 Variables
    var ghost2xGenTrans=16;
    var ghost2yGenTrans=8;
    var ghost2xTrans=16;
    var ghost2yTrans=8;
    var ghost2RightCounter=0;
    var ghost2UpCounter=0;
    var ghost2DownCounter=0;
    var ghost2LeftCounter=0;
    var ghost2Direction=1;

    //Ghost 3 Variables
    var ghost3xGenTrans=0;
    var ghost3yGenTrans=-8;
    var ghost3xTrans=0;
    var ghost3yTrans=-8;
    var ghost3RightCounter=0;
    var ghost3UpCounter=0;
    var ghost3DownCounter=0;
    var ghost3LeftCounter=0;
    var ghost3Direction=3;










    //LEVEL 2

     //Ghost 1 Variables
    var L2ghost1xGenTrans=-16;
    var L2ghost1yGenTrans=8;
    var L2ghost1xTrans=-16;
    var L2ghost1yTrans=8;
    var L2ghost1RightCounter=0;
    var L2ghost1UpCounter=0;
    var L2ghost1DownCounter=0;
    var L2ghost1LeftCounter=0;
    var L2ghost1Direction=3;

    //Ghost 2 Variables
    var L2ghost2xGenTrans=16;
    var L2ghost2yGenTrans=8;
    var L2ghost2xTrans=16;
    var L2ghost2yTrans=8;
    var L2ghost2RightCounter=0;
    var L2ghost2UpCounter=0;
    var L2ghost2DownCounter=0;
    var L2ghost2LeftCounter=0;
    var L2ghost2Direction=4;

    //Ghost 3 Variables
    var L2ghost3xGenTrans=0;
    var L2ghost3yGenTrans=-8;
    var L2ghost3xTrans=0;
    var L2ghost3yTrans=-8;
    var L2ghost3RightCounter=0;
    var L2ghost3UpCounter=0;
    var L2ghost3DownCounter=0;
    var L2ghost3LeftCounter=0;
    var L2ghost3Direction=2;




    //I use animate to implement the movement of the ghosts(nothing sophisticated :P)
    function animate() {

        if (lives<=0){
            document.getElementById("over").style.display="block";
            document.getElementById("TUCWebGL").style.display="none";
            lives=0;
        }
      
        
        document.getElementById("lives").innerHTML = lives;
        document.getElementById("score").innerHTML = score;

        //Ghost 1 Animation
        //Right Move
        if (ghost1Direction==3 && ghost1Direction!=1){
            if (level1[parseInt(-1*ghost1yGenTrans)/2+5][parseInt(ghost1xGenTrans)/2+9+1]!=1){
                ghost1Direction=3;
                ghost1xTrans=ghost1xTrans+0.05;
                ghost1RightCounter=ghost1RightCounter+0.05;
                if (ghost1RightCounter>2){
                    ghost1xGenTrans = ghost1xGenTrans+2;
                    ghost1xTrans=ghost1xGenTrans;
                    ghost1RightCounter=0;
                }
            }
            else{
                if (level1[parseInt(-1*ghost1yGenTrans)/2+5-1][parseInt(ghost1xGenTrans)/2+9]!=1){
                    ghost1Direction=2;
                }
                else{
                    ghost1Direction=4;
                }
            }
        }
        //Down Move
        if (ghost1Direction==4){
            if (level1[parseInt(-1*ghost1yGenTrans)/2+5+1][parseInt(ghost1xGenTrans)/2+9]!=1){
                ghost1Direction=4;
                ghost1yTrans=ghost1yTrans-0.05;
                ghost1DownCounter=ghost1DownCounter+0.05;
                if (ghost1DownCounter>2){
                    ghost1yGenTrans=ghost1yGenTrans-2;
                    ghost1yTrans=ghost1yGenTrans;
                    ghost1DownCounter=0;
                }   
            }
            else{
                if (level1[parseInt(-1*ghost1yGenTrans)/2+5][parseInt(ghost1xGenTrans)/2+9-1]!=1){
                    ghost1Direction=1;
                }
                else{
                    ghost1Direction=3;
                }
            }
        }
        //Left Move
        if (ghost1Direction==1){
            if (level1[parseInt(-1*ghost1yGenTrans)/2+5][parseInt(ghost1xGenTrans)/2+9-1]!=1){
                ghost1Direction=1;
                ghost1xTrans=ghost1xTrans-0.05;
                ghost1LeftCounter=ghost1LeftCounter+0.05;
                if (ghost1LeftCounter>2){
                    ghost1xGenTrans = ghost1xGenTrans-2;
                    ghost1xTrans=ghost1xGenTrans;
                    ghost1LeftCounter=0;
                }
            }
            else{
                if (level1[parseInt(-1*ghost1yGenTrans)/2+5-1][parseInt(ghost1xGenTrans)/2+9]!=1){
                    ghost1Direction=2;
                }
                else{
                    ghost1Direction=4;
                }
            }
        }
        //Up Move
        if (ghost1Direction==2){
            if (level1[parseInt(-1*ghost1yGenTrans)/2+5-1][parseInt(ghost1xGenTrans)/2+9]!=1){
                ghost1Direction=2;
                ghost1yTrans=ghost1yTrans+0.05;
                ghost1UpCounter=ghost1UpCounter+0.05;
                if (ghost1UpCounter>2){
                    ghost1yGenTrans=ghost1yGenTrans+2;
                    ghost1yTrans=ghost1yGenTrans;
                    ghost1UpCounter=0;
                }   
            }
            else{
                if (level1[parseInt(-1*ghost1yGenTrans)/2+5][parseInt(ghost1xGenTrans)/2+9-1]!=1){
                    ghost1Direction=1;
                }
                else{
                    ghost1Direction=3;
                }
            }
        }
        
        //Ghost 1 side cases
        if (ghost1yGenTrans==8 && ghost1xGenTrans<-18){
            ghost1xGenTrans=18;
        }
        if (ghost1yGenTrans==8 && ghost1xGenTrans>18){
            ghost1xGenTrans=-18;
        }


        //Change Direction when super pellet is eaten
        if (level1Complete!=1){
            if (ghost1Direction==3){
                if (superHelp1==1){
                    ghost1Direction=1;
                    superHelp1=0;
                }
            }
            else if (ghost1Direction==1){
                if (superHelp1==1){
                    ghost1Direction=3;
                    superHelp1=0;
                }
            }
            else if (ghost1Direction==2){
                if (superHelp1==1){
                    ghost1Direction=2;
                    superHelp1=0;
                }
            }
            else if (ghost1Direction==4){
                if (superHelp1==1){
                    ghost1Direction=2;
                    superHelp1=0;
                }
            }
        }        

        //Ghost 1 vs Pacman
        if (level1Complete!=1){
            if ((ghost1xTrans==xTrans && Math.abs(ghost1yTrans-yTrans)<1) || (Math.abs(ghost1xTrans-xTrans)<1 && ghost1yTrans==yTrans)){
                if (superTime==1){
                    ghost1xTrans=-16;
                    ghost1yTrans=8;
                    ghost1xGenTrans=-16;
                    ghost1yGenTrans=8;
                    score=score+50;
                }
                else{
                    xTrans=0;
                    yTrans=0;
                    xGenTrans=0;
                    yGenTrans=0;
                    lives--;
                }
            }  
        }
        

        //Ghost 2 Animation
        //Right Move
        if (ghost2Direction==3 && ghost2Direction!=1){
            if (level1g[parseInt(-1*ghost2yGenTrans)/2+5][parseInt(ghost2xGenTrans)/2+9+1]!=1){
                ghost2Direction=3;
                ghost2xTrans=ghost2xTrans+0.05;
                ghost2RightCounter=ghost2RightCounter+0.05;
                if (ghost2RightCounter>2){
                    ghost2xGenTrans = ghost2xGenTrans+2;
                    ghost2xTrans=ghost2xGenTrans;
                    ghost2RightCounter=0;
                }
            }
            else{
                if (level1g[parseInt(-1*ghost2yGenTrans)/2+5-1][parseInt(ghost2xGenTrans)/2+9]!=1){
                    ghost2Direction=2;
                }
                else{
                    ghost2Direction=4;
                }
            }
        }
        //Down Move
        if (ghost2Direction==4){
            if (level1g[parseInt(-1*ghost2yGenTrans)/2+5+1][parseInt(ghost2xGenTrans)/2+9]!=1){
                ghost2Direction=4;
                ghost2yTrans=ghost2yTrans-0.05;
                ghost2DownCounter=ghost2DownCounter+0.05;
                if (ghost2DownCounter>2){
                    ghost2yGenTrans=ghost2yGenTrans-2;
                    ghost2yTrans=ghost2yGenTrans;
                    ghost2DownCounter=0;
                }   
            }
            else{
                if (level1g[parseInt(-1*ghost2yGenTrans)/2+5][parseInt(ghost2xGenTrans)/2+9-1]!=1){
                    ghost2Direction=1;
                }
                else{
                    ghost2Direction=3;
                }
            }
        }
        //Left Move
        if (ghost2Direction==1){
            if (level1g[parseInt(-1*ghost2yGenTrans)/2+5][parseInt(ghost2xGenTrans)/2+9-1]!=1){
                ghost2Direction=1;
                ghost2xTrans=ghost2xTrans-0.05;
                ghost2LeftCounter=ghost2LeftCounter+0.05;
                if (ghost2LeftCounter>2){
                    ghost2xGenTrans = ghost2xGenTrans-2;
                    ghost2xTrans=ghost2xGenTrans;
                    ghost2LeftCounter=0;
                }
            }
            else{
                if (level1g[parseInt(-1*ghost2yGenTrans)/2+5-1][parseInt(ghost2xGenTrans)/2+9]!=1){
                    ghost2Direction=2;
                }
                else{
                    ghost2Direction=4;
                }
            }
        }
        //Up Move
        if (ghost2Direction==2){
            if (level1g[parseInt(-1*ghost2yGenTrans)/2+5-1][parseInt(ghost2xGenTrans)/2+9]!=1){
                ghost2Direction=2;
                ghost2yTrans=ghost2yTrans+0.05;
                ghost2UpCounter=ghost2UpCounter+0.05;
                if (ghost2UpCounter>2){
                    ghost2yGenTrans=ghost2yGenTrans+2;
                    ghost2yTrans=ghost2yGenTrans;
                    ghost2UpCounter=0;
                }   
            }
            else{
                if (level1g[parseInt(-1*ghost2yGenTrans)/2+5][parseInt(ghost2xGenTrans)/2+9-1]!=1){
                    ghost2Direction=1;
                }
                else{
                    ghost2Direction=3;
                }
            }
        }
        
        //Ghost 2 side cases
        if (ghost2yGenTrans==8 && ghost2xGenTrans<-18){
            ghost2xGenTrans=18;
        }
        if (ghost2yGenTrans==8 && ghost2xGenTrans>18){
            ghost2xGenTrans=-18;
        }

        //Change Direction when super pellet is eaten
        if (level1Complete!=1){
            if (ghost2Direction==3){
                if (superHelp2==1){
                    ghost2Direction=1;
                    superHelp2=0;
                }
            }
            else if (ghost2Direction==1){
                if (superHelp2==1){
                    ghost2Direction=3;
                    superHelp2=0;
                }
            }
            else if (ghost2Direction==2){
                if (superHelp2==1){
                    ghost2Direction=2;
                    superHelp2=0;
                }
            }
            else if (ghost2Direction==4){
                if (superHelp2==1){
                    ghost2Direction=2;
                    superHelp2=0;
                }
            }
        }

        //Ghost 2 vs Pacman
        if (level1Complete!=1){
            if ((ghost2xTrans==xTrans && Math.abs(ghost2yTrans-yTrans)<1) || (Math.abs(ghost2xTrans-xTrans)<1 && ghost2yTrans==yTrans)){
                if (superTime==1){
                    ghost2xTrans=16;
                    ghost2yTrans=8;
                    ghost2xGenTrans=16;
                    ghost2yGenTrans=8;
                    score=score+50;
                }
                else{
                    xTrans=0;
                    yTrans=0;
                    xGenTrans=0;
                    yGenTrans=0;
                    lives--;
                }
            }    
        }
        

        //Ghost 3 Animation
        //Right Move
        if (ghost3Direction==3 && ghost3Direction!=1){
            if (level1g2[parseInt(-1*ghost3yGenTrans)/2+5][parseInt(ghost3xGenTrans)/2+9+1]!=1){
                ghost3Direction=3;
                ghost3xTrans=ghost3xTrans+0.05;
                ghost3RightCounter=ghost3RightCounter+0.05;
                if (ghost3RightCounter>2){
                    ghost3xGenTrans = ghost3xGenTrans+2;
                    ghost3xTrans=ghost3xGenTrans;
                    ghost3RightCounter=0;
                }
            }
            else{
                if (level1g2[parseInt(-1*ghost3yGenTrans)/2+5-1][parseInt(ghost3xGenTrans)/2+9]!=1){
                    ghost3Direction=2;
                }
                else{
                    ghost3Direction=4;
                }
            }
        }
        //Down Move
        if (ghost3Direction==4){
            if (level1g2[parseInt(-1*ghost3yGenTrans)/2+5+1][parseInt(ghost3xGenTrans)/2+9]!=1){
                ghost3Direction=4;
                ghost3yTrans=ghost3yTrans-0.05;
                ghost3DownCounter=ghost3DownCounter+0.05;
                if (ghost3DownCounter>2){
                    ghost3yGenTrans=ghost3yGenTrans-2;
                    ghost3yTrans=ghost3yGenTrans;
                    ghost3DownCounter=0;
                }   
            }
            else{
                if (level1g2[parseInt(-1*ghost3yGenTrans)/2+5][parseInt(ghost3xGenTrans)/2+9-1]!=1){
                    ghost3Direction=1;
                }
                else{
                    ghost3Direction=3;
                }
            }
        }
        //Left Move
        if (ghost3Direction==1){
            if (level1g2[parseInt(-1*ghost3yGenTrans)/2+5][parseInt(ghost3xGenTrans)/2+9-1]!=1){
                ghost3Direction=1;
                ghost3xTrans=ghost3xTrans-0.05;
                ghost3LeftCounter=ghost3LeftCounter+0.05;
                if (ghost3LeftCounter>2){
                    ghost3xGenTrans = ghost3xGenTrans-2;
                    ghost3xTrans=ghost3xGenTrans;
                    ghost3LeftCounter=0;
                }
            }
            else{
                if (level1g2[parseInt(-1*ghost3yGenTrans)/2+5-1][parseInt(ghost3xGenTrans)/2+9]!=1){
                    ghost3Direction=2;
                }
                else{
                    ghost3Direction=4;
                }
            }
        }
        //Up Move
        if (ghost3Direction==2){
            if (level1g2[parseInt(-1*ghost3yGenTrans)/2+5-1][parseInt(ghost3xGenTrans)/2+9]!=1){
                ghost3Direction=2;
                ghost3yTrans=ghost3yTrans+0.05;
                ghost3UpCounter=ghost3UpCounter+0.05;
                if (ghost3UpCounter>2){
                    ghost3yGenTrans=ghost3yGenTrans+2;
                    ghost3yTrans=ghost3yGenTrans;
                    ghost3UpCounter=0;
                }   
            }
            else{
                if (level1g2[parseInt(-1*ghost3yGenTrans)/2+5][parseInt(ghost3xGenTrans)/2+9-1]!=1){
                    ghost3Direction=1;
                }
                else{
                    ghost3Direction=3;
                }
            }
        }
        
        //Ghost 3 side cases
        if (ghost3yGenTrans==8 && ghost3xGenTrans<-18){
            ghost3xGenTrans=18;
        }
        if (ghost3yGenTrans==8 && ghost3xGenTrans>18){
            ghost3xGenTrans=-18;
        }

        //Change Direction when super pellet is eaten
        if (level1Complete!=1){
            if (ghost3Direction==3){
                if (superHelp3==1){
                    ghost3Direction=1;
                    superHelp3=0;
                }
            }
            else if (ghost3Direction==1){
                if (superHelp3==1){
                    ghost3Direction=3;
                    superHelp3=0;
                }
            }
            else if (ghost3Direction==2){
                if (superHelp3==1){
                    ghost3Direction=4;
                    superHelp3=0;
                }
            }
            else if (ghost3Direction==4){
                if (superHelp3==1){
                    ghost3Direction=2;
                    superHelp3=0;
                }
            }
        }

        //Ghost 3 vs Pacman
        if (level1Complete!=1){
            if ((ghost3xTrans==xTrans && Math.abs(ghost3yTrans-yTrans)<1) || (Math.abs(ghost3xTrans-xTrans)<1 && ghost3yTrans==yTrans)){
                if (superTime==1){
                    ghost3xTrans=0;
                    ghost3yTrans=-8;
                    ghost3xGenTrans=0;
                    ghost3yGenTrans=-8;
                    score=score+50;
                }
                else{
                    xTrans=0;
                    yTrans=0;
                    xGenTrans=0;
                    yGenTrans=0;
                    lives--;
                }
            }
        }
        


















        //Level2 Ghost 1
        //Ghost 1 Animation
        //Right Move
        if (L2ghost1Direction==3 && L2ghost1Direction!=1){
            if (level2[parseInt(-1*L2ghost1yGenTrans)/2+5][parseInt(L2ghost1xGenTrans)/2+9+1]!=1){
                L2ghost1Direction=3;
                L2ghost1xTrans=L2ghost1xTrans+0.05;
                L2ghost1RightCounter=L2ghost1RightCounter+0.05;
                if (L2ghost1RightCounter>2){
                    L2ghost1xGenTrans = L2ghost1xGenTrans+2;
                    L2ghost1xTrans=L2ghost1xGenTrans;
                    L2ghost1RightCounter=0;
                }
            }
            else{
                if (level2[parseInt(-1*L2ghost1yGenTrans)/2+5-1][parseInt(L2ghost1xGenTrans)/2+9]!=1){
                    L2ghost1Direction=2;
                }
                else{
                    L2ghost1Direction=4;
                }
            }
        }
        //Down Move
        if (L2ghost1Direction==4){
            if (level2[parseInt(-1*L2ghost1yGenTrans)/2+5+1][parseInt(L2ghost1xGenTrans)/2+9]!=1){
                L2ghost1Direction=4;
                L2ghost1yTrans=L2ghost1yTrans-0.05;
                L2ghost1DownCounter=L2ghost1DownCounter+0.05;
                if (L2ghost1DownCounter>2){
                    L2ghost1yGenTrans=L2ghost1yGenTrans-2;
                    L2ghost1yTrans=L2ghost1yGenTrans;
                    L2ghost1DownCounter=0;
                }   
            }
            else{
                if (level2[parseInt(-1*L2ghost1yGenTrans)/2+5][parseInt(L2ghost1xGenTrans)/2+9-1]!=1){
                    L2ghost1Direction=1;
                }
                else{
                    L2ghost1Direction=3;
                }
            }
        }
        //Left Move
        if (L2ghost1Direction==1){
            if (level2[parseInt(-1*L2ghost1yGenTrans)/2+5][parseInt(L2ghost1xGenTrans)/2+9-1]!=1){
                L2ghost1Direction=1;
                L2ghost1xTrans=L2ghost1xTrans-0.05;
                L2ghost1LeftCounter=L2ghost1LeftCounter+0.05;
                if (L2ghost1LeftCounter>2){
                    L2ghost1xGenTrans = L2ghost1xGenTrans-2;
                    L2ghost1xTrans=L2ghost1xGenTrans;
                    L2ghost1LeftCounter=0;
                }
            }
            else{
                if (level2[parseInt(-1*L2ghost1yGenTrans)/2+5-1][parseInt(L2ghost1xGenTrans)/2+9]!=1){
                    L2ghost1Direction=2;
                }
                else{
                    L2ghost1Direction=4;
                }
            }
        }
        //Up Move
        if (L2ghost1Direction==2){
            if (level2[parseInt(-1*L2ghost1yGenTrans)/2+5-1][parseInt(L2ghost1xGenTrans)/2+9]!=1){
                L2ghost1Direction=2;
                L2ghost1yTrans=L2ghost1yTrans+0.05;
                L2ghost1UpCounter=L2ghost1UpCounter+0.05;
                if (L2ghost1UpCounter>2){
                    L2ghost1yGenTrans=L2ghost1yGenTrans+2;
                    L2ghost1yTrans=L2ghost1yGenTrans;
                    L2ghost1UpCounter=0;
                }   
            }
            else{
                if (level2[parseInt(-1*L2ghost1yGenTrans)/2+5][parseInt(L2ghost1xGenTrans)/2+9-1]!=1){
                    L2ghost1Direction=1;
                }
                else{
                    L2ghost1Direction=3;
                }
            }
        }
        
        //Ghost 1 side cases
        if (L2ghost1yGenTrans==0 && L2ghost1xGenTrans<-18){
            L2ghost1xGenTrans=18;
        }
        if (L2ghost1yGenTrans==0 && L2ghost1xGenTrans>18){
            L2ghost1xGenTrans=-18;
        }

        //Change Direction when super pellet is eaten
        if (L2ghost1Direction==3){
            if (superHelp1==1){
                L2ghost1Direction=1;
                superHelp1=0;
            }
        }
        else if (L2ghost1Direction==1){
            if (superHelp1==1){
                L2ghost1Direction=3;
                superHelp1=0;
            }
        }
        else if (L2ghost1Direction==2){
            if (superHelp1==1){
                L2ghost1Direction=4;
                superHelp1=0;
            }
        }
        else if (L2ghost1Direction==4){
            if (superHelp1==1){
                L2ghost1Direction=2;
                superHelp1=0;
            }
        }

        //Ghost 1 vs Pacman
        if (level1Complete==1){
            if ((L2ghost1xTrans==xTrans && Math.abs(L2ghost1yTrans-yTrans)<1) || (Math.abs(L2ghost1xTrans-xTrans)<1 && L2ghost1yTrans==yTrans)){
                if (superTime==1){
                    L2ghost1xTrans=-16;
                    L2ghost1yTrans=8;
                    L2ghost1xGenTrans=-16;
                    L2ghost1yGenTrans=8;
                    score=score+50;
                }
                else{
                    xTrans=0;
                    yTrans=0;
                    xGenTrans=0;
                    yGenTrans=0;
                    lives--;
                }
            }
        }
        
        //Ghost 2 Animation
        //Right Move
        if (L2ghost2Direction==3){
            if (level2g2[parseInt(-1*L2ghost2yGenTrans)/2+5][parseInt(L2ghost2xGenTrans)/2+9+1]!=1){
                L2ghost2Direction=3;
                L2ghost2xTrans=L2ghost2xTrans+0.05;
                L2ghost2RightCounter=L2ghost2RightCounter+0.05;
                if (L2ghost2RightCounter>2){
                    L2ghost2xGenTrans = L2ghost2xGenTrans+2;
                    L2ghost2xTrans=L2ghost2xGenTrans;
                    L2ghost2RightCounter=0;
                }
            }
            else{
                if (level2g2[parseInt(-1*L2ghost2yGenTrans)/2+5-1][parseInt(L2ghost2xGenTrans)/2+9]!=1){
                    L2ghost2Direction=2;
                }
                else{
                    L2ghost2Direction=4;
                }
            }
        }
        //Down Move
        if (L2ghost2Direction==4){
            if (level2g2[parseInt(-1*L2ghost2yGenTrans)/2+5+1][parseInt(L2ghost2xGenTrans)/2+9]!=1){
                L2ghost2Direction=4;
                L2ghost2yTrans=L2ghost2yTrans-0.05;
                L2ghost2DownCounter=L2ghost2DownCounter+0.05;
                if (L2ghost2DownCounter>2){
                    L2ghost2yGenTrans=L2ghost2yGenTrans-2;
                    L2ghost2yTrans=L2ghost2yGenTrans;
                    L2ghost2DownCounter=0;
                }   
            }
            else{
                if (level2g2[parseInt(-1*L2ghost2yGenTrans)/2+5][parseInt(L2ghost2xGenTrans)/2+9-1]!=1){
                    L2ghost2Direction=1;
                }
                else{
                    L2ghost2Direction=3;
                }
            }
        }
        //Left Move
        if (L2ghost2Direction==1){
            if (level2g2[parseInt(-1*L2ghost2yGenTrans)/2+5][parseInt(L2ghost2xGenTrans)/2+9-1]!=1){
                L2ghost2Direction=1;
                L2ghost2xTrans=L2ghost2xTrans-0.05;
                L2ghost2LeftCounter=L2ghost2LeftCounter+0.05;
                if (L2ghost2LeftCounter>2){
                    L2ghost2xGenTrans = L2ghost2xGenTrans-2;
                    L2ghost2xTrans=L2ghost2xGenTrans;
                    L2ghost2LeftCounter=0;
                }
            }
            else{
                if (level2g2[parseInt(-1*L2ghost2yGenTrans)/2+5-1][parseInt(L2ghost2xGenTrans)/2+9]!=1){
                    L2ghost2Direction=2;
                }
                else{
                    L2ghost2Direction=4;
                }
            }
        }
        //Up Move
        if (L2ghost2Direction==2){
            if (level2g2[parseInt(-1*L2ghost2yGenTrans)/2+5-1][parseInt(L2ghost2xGenTrans)/2+9]!=1){
                L2ghost2Direction=2;
                L2ghost2yTrans=L2ghost2yTrans+0.05;
                L2ghost2UpCounter=L2ghost2UpCounter+0.05;
                if (L2ghost2UpCounter>2){
                    L2ghost2yGenTrans=L2ghost2yGenTrans+2;
                    L2ghost2yTrans=L2ghost2yGenTrans;
                    L2ghost2UpCounter=0;
                }   
            }
            else{
                if (level2g2[parseInt(-1*L2ghost2yGenTrans)/2+5][parseInt(L2ghost2xGenTrans)/2+9-1]!=1){
                    L2ghost2Direction=1;
                }
                else{
                    L2ghost2Direction=3;
                }
            }
        }
        
        //Ghost 2 side cases
        if (L2ghost2yGenTrans==0 && L2ghost2xGenTrans<-18){
            L2ghost2xGenTrans=18;
        }
        if (L2ghost2yGenTrans==0 && L2ghost2xGenTrans>18){
            L2ghost2xGenTrans=-18;
        }

        //Change Direction when super pellet is eaten
        if (L2ghost2Direction==3){
            if (superHelp2==1){
                L2ghost2Direction=1;
                superHelp2=0;
            }
        }
        else if (L2ghost2Direction==1){
            if (superHelp2==1){
                L2ghost2Direction=3;
                superHelp2=0;
            }
        }
        else if (L2ghost2Direction==2){
            if (superHelp2==1){
                L2ghost2Direction=2;
                superHelp2=0;
            }
        }
        else if (L2ghost2Direction==4){
            if (superHelp2==1){
                L2ghost2Direction=2;
                superHelp2=0;
            }
        }

        //Ghost 2 vs Pacman
        if (level1Complete==1){
            if ((L2ghost2xTrans==xTrans && Math.abs(L2ghost2yTrans-yTrans)<1) || (Math.abs(L2ghost2xTrans-xTrans)<1 && L2ghost2yTrans==yTrans)){
                if (superTime==1){
                    L2ghost2xTrans=16;
                    L2ghost2yTrans=8;
                    L2ghost2xGenTrans=16;
                    L2ghost2yGenTrans=8;
                    score=score+50;
                }
                else{
                    xTrans=0;
                    yTrans=0;
                    xGenTrans=0;
                    yGenTrans=0;
                    lives--;
                }
            }
        }
        
        //Ghost 3 Animation
        //Right Move
        if (L2ghost3Direction==3 && L2ghost3Direction!=1){
            if (level2g3[parseInt(-1*L2ghost3yGenTrans)/2+5][parseInt(L2ghost3xGenTrans)/2+9+1]!=1){
                L2ghost3Direction=3;
                L2ghost3xTrans=L2ghost3xTrans+0.05;
                L2ghost3RightCounter=L2ghost3RightCounter+0.05;
                if (L2ghost3RightCounter>2){
                    L2ghost3xGenTrans = L2ghost3xGenTrans+2;
                    L2ghost3xTrans=L2ghost3xGenTrans;
                    L2ghost3RightCounter=0;
                }
            }
            else{
                if (level2g3[parseInt(-1*L2ghost3yGenTrans)/2+5-1][parseInt(L2ghost3xGenTrans)/2+9]!=1){
                    L2ghost3Direction=2;
                }
                else{
                    L2ghost3Direction=4;
                }
            }
        }
        //Down Move
        if (L2ghost3Direction==4){
            if (level2g3[parseInt(-1*L2ghost3yGenTrans)/2+5+1][parseInt(L2ghost3xGenTrans)/2+9]!=1){
                L2ghost3Direction=4;
                L2ghost3yTrans=L2ghost3yTrans-0.05;
                L2ghost3DownCounter=L2ghost3DownCounter+0.05;
                if (L2ghost3DownCounter>2){
                    L2ghost3yGenTrans=L2ghost3yGenTrans-2;
                    L2ghost3yTrans=L2ghost3yGenTrans;
                    L2ghost3DownCounter=0;
                }   
            }
            else{
                if (level2g3[parseInt(-1*L2ghost3yGenTrans)/2+5][parseInt(L2ghost3xGenTrans)/2+9-1]!=1){
                    L2ghost3Direction=1;
                }
                else{
                    L2ghost3Direction=3;
                }
            }
        }
        //Left Move
        if (L2ghost3Direction==1){
            if (level2g3[parseInt(-1*L2ghost3yGenTrans)/2+5][parseInt(L2ghost3xGenTrans)/2+9-1]!=1){
                L2ghost3Direction=1;
                L2ghost3xTrans=L2ghost3xTrans-0.05;
                L2ghost3LeftCounter=L2ghost3LeftCounter+0.05;
                if (L2ghost3LeftCounter>2){
                    L2ghost3xGenTrans = L2ghost3xGenTrans-2;
                    L2ghost3xTrans=L2ghost3xGenTrans;
                    L2ghost3LeftCounter=0;
                }
            }
            else{
                if (level2g3[parseInt(-1*L2ghost3yGenTrans)/2+5-1][parseInt(L2ghost3xGenTrans)/2+9]!=1){
                    L2ghost3Direction=2;
                }
                else{
                    L2ghost3Direction=4;
                }
            }
        }
        //Up Move
        if (L2ghost3Direction==2){
            if (level2g3[parseInt(-1*L2ghost3yGenTrans)/2+5-1][parseInt(L2ghost3xGenTrans)/2+9]!=1){
                L2ghost3Direction=2;
                L2ghost3yTrans=L2ghost3yTrans+0.05;
                L2ghost3UpCounter=L2ghost3UpCounter+0.05;
                if (L2ghost3UpCounter>2){
                    L2ghost3yGenTrans=L2ghost3yGenTrans+2;
                    L2ghost3yTrans=L2ghost3yGenTrans;
                    L2ghost3UpCounter=0;
                }   
            }
            else{
                if (level2g3[parseInt(-1*L2ghost3yGenTrans)/2+5][parseInt(L2ghost3xGenTrans)/2+9-1]!=1){
                    L2ghost3Direction=1;
                }
                else{
                    L2ghost3Direction=3;
                }
            }
        }
        
        //Ghost 3 side cases
        if (L2ghost3yGenTrans==0 && L2ghost3xGenTrans<-18){
            L2ghost3xGenTrans=18;
        }
        if (L2ghost3yGenTrans==0 && L2ghost3xGenTrans>18){
            L2ghost3xGenTrans=-18;
        }

        //Change Direction when super pellet is eaten
        if (L2ghost3Direction==3){
            if (superHelp3==1){
                L2ghost3Direction=1;
                superHelp3=0;
            }
        }
        else if (L2ghost3Direction==1){
            if (superHelp3==1){
                L2ghost3Direction=3;
                superHelp3=0;
            }
        }
        else if (L2ghost3Direction==2){
            if (superHelp3==1){
                L2ghost3Direction=4;
                superHelp3=0;
            }
        }
        else if (L2ghost3Direction==4){
            if (superHelp3==1){
                L2ghost3Direction=2;
                superHelp3=0;
            }
        }

        //Ghost 3 vs Pacman
        if (level1Complete==1){
            if ((L2ghost3xTrans==xTrans && Math.abs(L2ghost3yTrans-yTrans)<1) || (Math.abs(L2ghost3xTrans-xTrans)<1 && L2ghost3yTrans==yTrans)){
                if (superTime==1){
                    L2ghost3xTrans=0;
                    L2ghost3yTrans=-8;
                    L2ghost3xGenTrans=0;
                    L2ghost3yGenTrans=-8;
                    score=score+50;
                }
                else{
                    xTrans=0;
                    yTrans=0;
                    xGenTrans=0;
                    yGenTrans=0;
                    lives--;
                }
            }
        }
        
    }


	//this is the requestAnimFrame callback
	//For every tick, request another frame
	//handle keyboard, draw the scene, animate (update animation variebles) and continue
    function tick() {
        requestAnimFrame(tick);
		handleKeys();
        drawScene();
        animate();
				
    }

	//Entry point of the WebGL context
	function webGLStart() {
        var canvas = document.getElementById("TUCWebGL");
        
		//Functions for initialization
		//Check above
		initGL(canvas);
        initShaders()
        initBuffers();
        initTexture();

		//Background Color: Color assigned for all pixels with no corresponding fragments
        gl.clearColor(0.3, 0.3, 0.3, 1.0);
		
		//Enable z-buffer for depth sorting
        gl.enable(gl.DEPTH_TEST);

		//define the keyboard handlers
		document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;
		
		//the first tick of our application
        tick();
    }
//end of Javascript
</script>

</head>

<!-- HMTL for the canvas element-->
<body onload="webGLStart();"> <!-- calls the entry point of our application -->

    <audio src="theme.mp3" autoplay="autoplay" loop="loop"></audio>

    <canvas id="TUCWebGL" style="border: none;" width="700" height="500" style="display:block"></canvas> <br> <br>
    <!-- game over -->
    <img id="over" src="over.jpg"  width="700" height="500" style="display:none;" >

    <!-- win -->
    <img id="win" src="win.png"  width="700" height="500" style="display:none;" >

    <p style="color: black; float: left;"> Lives : </p> 
    <p id="lives" style="color: black;"></p> 
    
    <p style="color: black; float: left;"> Score : </p>
    <p id="score" style="color: black;"></p>

    

    <br>

</body></html>